/**
 * crash.ts â€“ funtion/s to report a bug on GitHub.
 */

import { app, shell, dialog } from "electron";
import * as colors from "colors/safe";
import * as newGithubIssueUrl from "new-github-issue-url";
import { appInfo } from "./mainGlobal";
import fetch from "electron-fetch";

/**
 * Generates a link to new GitHub issue, based on `bug_report.md`
 * and current hardware / software configuration. This makes it
 * easy to aquire needed details (except screenshot, because of
 * the lack of the GitHub support to do that via the CDN or using
 * 'base64' images).
 */
export async function createGithubIssue(): Promise<void> {

    /* Fetch issue template in markdown. */

    let markdownBody: string;
    {
        const arrayBody: Array<string> = [];
        arrayBody.push("**Note:** This issue was automatically generated by WebCord.");
        const markdownBugTemplate = await (await fetch('https://raw.githubusercontent.com/' + appInfo.repository.name + '/master/.github/ISSUE_TEMPLATE/bug_report.md')).text();

        /* Loop through all lines and edit properties according to OS specification. */

        for (const line of markdownBugTemplate.split('\n')) {
            let tempEdited: string = line, newValue: null | string = null;
            if (line.includes('Platform:'))
                newValue = '`' + process.platform + '`';
            if (line.includes('Architecture:'))
                newValue = '`' + process.arch + '`';
            if (line.includes('Electron version:'))
                newValue = '`' + 'v' + process.versions.electron + '`';
            if (line.includes('Application version:'))
                newValue = '`' + 'v' + app.getVersion() + '`';
            if (newValue !== null)
                tempEdited = line.replace(line.substr(line.indexOf(':') + 2), newValue);
            /* Do not push GitHub's template information */
            if (!tempEdited.match(/---|name:|title:|about:|assignees:|labels:/))
                arrayBody.push(tempEdited);
        }
        markdownBody = arrayBody.join('\n');
    }

    /* Generate template URL. */

    const githubIssueUrl = new URL(
        newGithubIssueUrl({
            repoUrl: 'https://github.com/' + appInfo.repository.name,
            body: markdownBody,
            assignee: 'SpacingBat3',
            labels: ['bug'],
            template: 'bug_report.md'
        })
    );

    /* Verify origin and open URL in default browser. */

    if (githubIssueUrl.origin === "https://github.com")
        shell.openExternal(githubIssueUrl.href);
}

/* Handles uncaughtException errors */

process.on('uncaughtException', async (error) => {
    let stack = "", message = "", stackColor = "";
    const name = "UncaughtException: " + app.getName() + " threw '" + error.name + "'.";
    if (error.message !== "")
        message = "\n\n" + error.message + "\n\n";


    if (error.stack !== undefined) {
        stack = "\n" + error.stack
            .replace(RegExp(error.name + ': ' + error.message), '');
        stackColor = stack;
        const stackLines = stack.split(/\r\n|\n|\r/);
        const stackProcessed: string[] = [], stackColorProcessed: string[] = [];
        for (const line of stackLines)
            if (line.match(RegExp("at.*\\(" + app.getAppPath() + ".*\\).*", 'g'))) {
                stackProcessed.push(line);
                stackColorProcessed.push(colors.bgRed(colors.white(line)));
            } else {
                stackColorProcessed.push(line);
            }
        stack = stackProcessed.join('\n');
        stackColor = stackColorProcessed.join('\n');
    }

    await app.whenReady();
    console.error('\n' + name + message + stackColor);
    dialog.showMessageBoxSync({
        title: name,
        message: message + stack,
        type: 'error'
    });

    let errCode: number;
    switch (error.name) {
        case "Error":
            errCode = 101;
            break;
        case "TypeError":
            errCode = 102;
            break;
        default:
            errCode = 100;
    }
    console.error("\nApplication crashed (Error code: " + errCode + ")\n");
    app.exit(errCode);
});